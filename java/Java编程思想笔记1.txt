1.引用操纵对象
String s;
这里所创建的s只是引用，并不是对象。如果想对s进行操作，必须关联对象。
String s = "abc";

2.创建对象
通常用new操作符创建对象。

3.存储位置
程序运行时，对象时怎么进行放置安排的？特别是内存是怎样分配的？
1）寄存器。不能直接控制，也不能在程序中感觉到寄存器存在的任何迹象（C和C++允许您想编译器建议寄存器的分配方式）。
2）堆栈。堆栈指针若向下移动，则分配新的内存；若向上移动，则释放那些内存。创建程序时，Java系统必须知道存储在堆栈内所有项的确切生命周期，以便上下移动堆栈指针。这一约束限制了程序的灵活性，所以虽然某些Java数据存储于堆栈中――――特别是对象引用，但是Java对象并不存储于其中。
3）堆。用于存放所有的Java对象。堆不同于堆栈的好处是：编译器不需要知道存储的数据在堆里存活多长时间。在堆进行存储分配和清理可能比用堆栈进行存储分配需要更多的时间（C++在栈中创建对象）。
4）常量存储。常量值通常直接存放在程序代码内部，因为它们永远不会被改变。
5）非RAM存储。流对象和持久化对象。

4.特例：基本类型
对于基本类型，Java采取与C和C++相同的方法。也就是说，不用new来创建变量，而是创建一个并非是引用的"自动"变量。这个变量直接存储"值"，并置于堆栈中。
Java中基本类型所占存储空间的大小并不想其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是Java程序比其他大多数语言编写的程序更具可移植性的原因之一。

5.Java中的数组
Java确保数组会被初始化，而且不能在它的范围之外被访问。这个范围检查，是以每个数组上少量的内存开销及运行时的下标检查为代价的。但由此换来的是安全性和效率的提高。
当创建一个数组对象时，实际上就是创建了一个引用数组，并且每个引用都会自动被初始化为一个特定值，该值拥有自己的关键字null。一旦Java看到null，就知道这个引用还没有指向某个对象。在使用任何引用前，必须为其制定一个对象。
对于基本数据类型的数组，初始化全为零。

6.作用域
Java中是以花括号的位置决定作用域的。
{
	int x = 12;
	{
		int x = 95;
	}
}
以上这段代码，在C和C++中是合法的，但是在Java中是不对的。
编译器将会报告变量x已经定义过。所以，在C和C++里讲一个较大作用域的变量"隐藏"起来的做法，在Java里是不允许的。

7.对象的作用域
Java对象不具备和基本类型一样的生命周期。当用new创建一个Java对象时，它可以存活于作用域之外。
{
	String s = new String("a String");
}
引用s在作用域终点就消失了。然而，s指向的String对象仍继续占据内存空间。在这小段代码中，我们无法在这个作用域之后访问这个对象，因为对它唯一的应用已超出了作用域的范围。
由new创建的对象，只要你需要，就会一直保留下去。这样，许多C++编程问题在Java中完全消失了。
在C++中，你不仅必须要确保对象的保留时间与你需要这些对象的时间一样长，而且还必须在你使用完它们之后，将其销毁。

8.如果Java让对象继续存在，那么靠什么才能防止这些对象填满内存空间，进而阻塞你的程序呢？
在C++中可能会发生这个问题。在Java里有一个垃圾回收器，用来监视用new创建的所有对象，并辨别那些不会再被引用的对象。随后，释放这些对象的内存空间。

9.基本成员默认值
在Java的类中，当变量作为类的成员使用时，Java才确保给定其默认值，以确保那些是基本类型的成员变量得到初始化（C++没有此功能）。
然而上述确保初始化的方法并不适用于"局部"变量（即并非某个类的字段）。
java将为初始化的局部变量视为错误，而C++编译器会对未初始化的变量给予警告。


